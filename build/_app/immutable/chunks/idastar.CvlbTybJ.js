import{F as k,G as m,I as d,J as o}from"./scheduler.DYp-TRml.js";import{g as w,a as y,c as b,t as x}from"./index.BHCOM26g.js";function O(a,t){const e=t.token={};function c(u,l,r,n){if(t.token!==e)return;t.resolved=n;let s=t.ctx;r!==void 0&&(s=s.slice(),s[r]=n);const i=u&&(t.current=u)(s);let f=!1;t.block&&(t.blocks?t.blocks.forEach((_,h)=>{h!==l&&_&&(w(),y(_,1,1,()=>{t.blocks[h]===_&&(t.blocks[h]=null)}),b())}):t.block.d(1),i.c(),x(i,1),i.m(t.mount(),t.anchor),f=!0),t.block=i,t.blocks&&(t.blocks[l]=i),f&&o()}if(k(a)){const u=m();if(a.then(l=>{d(u),c(t.then,1,t.value,l),d(null)},l=>{if(d(u),c(t.catch,2,t.error,l),d(null),!t.hasCatch)throw l}),t.current!==t.pending)return c(t.pending,0),!0}else{if(t.current!==t.then)return c(t.then,1,t.value,a),!0;t.resolved=a}}function E(a,t,e){const c=t.slice(),{resolved:u}=a;a.current===a.then&&(c[a.value]=u),a.current===a.catch&&(c[a.error]=u),a.block.p(c,e)}function I(a){for(let t=a.length-1;t>=1;t--){let e=Math.floor((t+1)*Math.random());[a[t],a[e]]=[a[e],a[t]]}}function G(a,t){if(!a)return;let e;return(...c)=>{clearTimeout(e),e=setTimeout(()=>a(...c),t)}}function g(a,t,e,c={}){let u=c.yields_per_interval||1e3,l=setInterval(()=>{for(let r=0;r<u;r++){let{value:n,done:s}=a.next();if(s){e&&e(n),clearInterval(l);break}t&&t(n)}},c.interval||10);if(c.signal){let r=function(){clearInterval(l)};c.signal.addEventListener("abort",r,{once:!0})}}function M(a=(t,e)=>t<e){var t=[];function e(r){return Math.floor((r-1)/2)}function c(r){return 2*r+1}function u(r){return 2*r+2}function l(r){var n,s=t.length;if(s!==1){var i=c(r),f=u(r),_=r;i<s&&a(t[i],t[r])&&(_=i),f<s&&a(t[f],t[_])&&(_=f),_!==r&&(n=[t[_],t[r]],t[r]=n[0],t[_]=n[1],l(_))}}return{length:()=>t.length,clear:()=>{t=[]},getMin:function(){return t[0]},popMin:function(){if(t.length<=1)return t.pop();[t[0],t[t.length-1]]=[t[t.length-1],t[0]];var r=t.pop();return l(0),r},insert:function(r){var n;t.push(r);for(var s=t.length-1;s>0&&a(t[s],t[e(s)]);){var i=e(s);n=[t[i],t[s]],t[s]=n[0],t[i]=n[1],s=i}}}}function*S(a,t,e=JSON.stringify){var f;let c=new Map,u=M((_,h)=>_.total_cost+_.heuristic<h.total_cost+h.heuristic);u.insert({prev_state:void 0,state:a.start_state,total_cost:0,heuristic:t(a.start_state)});let l=0,r,n;for(;u.length()>0;){n=[void 0,[]],l++;do r=u.popMin();while(r&&c.has(e(r.state)));if(!r||(c.set(e(r.state),{total_cost:r.total_cost,prev_state:r.prev_state,heuristic:r.heuristic}),a.is_end(r.state)))break;n[0]=r.state;for(const{next_state:_,cost:h}of a.succ_and_cost(r.state)){if(c.has(e(_)))continue;let v=t(_);u.insert({total_cost:r.total_cost+h,prev_state:r.state,state:_,heuristic:v}),n[1].push(_)}yield n}if(!r)return{success:!1};let s=[],i=r.state;for(;i;)s.push(i),i=(f=c.get(e(i)))==null?void 0:f.prev_state;return s.reverse(),{success:!0,route:s,total_cost:r.total_cost,iterations:l}}function L(a,t,e){return new Promise((u,l)=>{var n;(n=e==null?void 0:e.signal)!=null&&n.aborted&&l(e.signal.reason);const r=S(a,t,(e==null?void 0:e.hash)||JSON.stringify);g(r,e==null?void 0:e.on_progress,s=>u(s),e),e!=null&&e.signal&&e.signal.addEventListener("abort",()=>{var s;l((s=e.signal)==null?void 0:s.reason)},{once:!0})})}async function D(a,t,e){let c=t(a.start_state);for(;;){let l=await new Promise((r,n)=>{var i;(i=e==null?void 0:e.signal)!=null&&i.aborted&&n(e.signal.reason);let s=A(a,t,c,(e==null?void 0:e.hash)||JSON.stringify);g(s,e==null?void 0:e.on_progress,f=>r(f),e),e!=null&&e.signal&&e.signal.addEventListener("abort",()=>{var f;return n((f=e.signal)==null?void 0:f.reason)},{once:!0})});if(l.success)return l;if(l.min==1/0)return{success:!1};e!=null&&e.on_iteration_done&&e.on_iteration_done(c),c=l.min}}function*A(a,t,e,c=JSON.stringify){let u=[{state:a.start_state,succ:a.succ_and_cost(a.start_state),total_cost:0}],l=[c(a.start_state)],r=1/0;yield[u[0].state,[]];let n=[];for(;u.length>0;){let s=u.at(-1),i=s.total_cost+t(s.state);if(i>e){r=i<r?i:r,n.push(u.pop().state),l.pop();continue}if(a.is_end(s.state))return{success:!0,route:u.map(_=>_.state),total_cost:s.total_cost};let f=s.succ.pop();if(!f){l.pop(),n.push(u.pop().state);continue}u.push({state:f.next_state,total_cost:s.total_cost+f.cost,succ:a.succ_and_cost(f.next_state).filter(({next_state:_})=>l.indexOf(c(_))==-1)}),l.push(c(f.next_state)),yield[f.next_state,n],n=[]}return{success:!1,min:r}}export{L as A,D as I,G as d,O as h,I as s,E as u};
